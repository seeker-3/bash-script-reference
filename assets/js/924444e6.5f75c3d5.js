"use strict";(self.webpackChunkbash_script_reference=self.webpackChunkbash_script_reference||[]).push([[867],{4329:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"functions","title":"Functions","description":"Functions are a way to group commands together and reuse them. They behave like commands and can take arguments and return exit codes.","source":"@site/docs/006-functions.md","sourceDirName":".","slug":"/functions","permalink":"/bash-script-reference/docs/functions","draft":false,"unlisted":false,"editUrl":"https://github.com/seeker-3/bash-script-reference/tree/main/docs/006-functions.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"referenceSidebar","previous":{"title":"Associative Arrays","permalink":"/bash-script-reference/docs/associative-arrays"},"next":{"title":"Word Splitting (Biggest Footgun)","permalink":"/bash-script-reference/docs/word-splitting"}}');var r=s(6070),a=s(5658);const c={},t="Functions",l={},o=[{value:"Defining Functions <code>fn() { ... }</code>",id:"defining-functions-fn---",level:2},{value:"Calling Functions <code>fn</code>",id:"calling-functions-fn",level:2},{value:"Calling Functions with Arguments <code>fn 1 2 3</code>",id:"calling-functions-with-arguments-fn-1-2-3",level:2},{value:"Using Functions Arguments <code>&quot;$@&quot;</code>",id:"using-functions-arguments-",level:2},{value:"Local Variables <code>local</code>",id:"local-variables-local",level:2},{value:"Local Variable References <code>local -n</code>",id:"local-variable-references-local--n",level:2},{value:"Returning Exit Codes <code>return</code>",id:"returning-exit-codes-return",level:2},{value:"&quot;Returning&quot; a Value <code>echo ...</code>",id:"returning-a-value-echo-",level:2},{value:"Brackets vs. Parentheses",id:"brackets-vs-parentheses",level:2},{value:"Passing STDIN to Functions",id:"passing-stdin-to-functions",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"functions",children:"Functions"})}),"\n",(0,r.jsx)(n.p,{children:"Functions are a way to group commands together and reuse them. They behave like commands and can take arguments and return exit codes."}),"\n",(0,r.jsxs)(n.h2,{id:"defining-functions-fn---",children:["Defining Functions ",(0,r.jsx)(n.code,{children:"fn() { ... }"})]}),"\n",(0,r.jsxs)(n.p,{children:["Function identifiers are more permissive than variable identifiers, for instance you can use ",(0,r.jsx)(n.code,{children:"-"})," and ",(0,r.jsx)(n.code,{children:"+"})," in function names, but I personally recommend sticking to the same naming conventions as variables, ",(0,r.jsx)(n.code,{children:"[_a-zA-Z][_a-zA-Z0-9]*"}),", an underscore or letter, followed by underscores, letters, or numbers. Functions are conventionally defined using lower snake case ",(0,r.jsx)(n.code,{children:"my_function"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Functions are defined in the following way:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"fn() {\n  echo 'Hello, World!'\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Bash also has a ",(0,r.jsx)(n.code,{children:"function"})," keyword for declaring functions, but the shorthand above is preferred."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"function fn() {\n  echo 'Hello, World!'\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"calling-functions-fn",children:["Calling Functions ",(0,r.jsx)(n.code,{children:"fn"})]}),"\n",(0,r.jsx)(n.p,{children:"Call a function like running a command."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"fn\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"calling-functions-with-arguments-fn-1-2-3",children:["Calling Functions with Arguments ",(0,r.jsx)(n.code,{children:"fn 1 2 3"})]}),"\n",(0,r.jsx)(n.p,{children:"Pass arguments to a function by separating them with spaces just like running a command."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"fn arg1 arg2 arg3\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"using-functions-arguments-",children:["Using Functions Arguments ",(0,r.jsx)(n.code,{children:'"$@"'})]}),"\n",(0,r.jsxs)(n.p,{children:["Function arguments are access the same way as cli arguments using ",(0,r.jsx)(n.a,{href:"special-parameters",children:"special parameters"}),". Arguments are not explicitly declared in the function's signature."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'fn() {\n  # First argument\n  echo "$1" # arg1\n  # Second argument\n  echo "$2" # arg2\n  # Third argument\n  echo "$3" # arg3\n  # All arguments as separate strings\n  echo "$@" # \'arg1\' \'arg2\' \'arg3\'\n  # Number of arguments\n  echo "$#" # 3\n  # Still echoes arg0 of the cli and not the function name\n  echo "$0" # functions.bash\n  # All arguments as a single string\n  echo "$*" # \'arg1 arg2 arg3\'\n}\n\nfn arg1 arg2 arg3\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"bonus#shellcheck-a-shell-script-linter",children:(0,r.jsx)(n.code,{children:"shellcheck"})})," will warn you if you do not supply the right number of arguments when calling a function."]}),"\n",(0,r.jsxs)(n.h2,{id:"local-variables-local",children:["Local Variables ",(0,r.jsx)(n.code,{children:"local"})]}),"\n",(0,r.jsxs)(n.p,{children:["Local variables can be defined inside a function using the ",(0,r.jsx)(n.code,{children:"local"})," keyword. It is my preference to use lower snake case for local variables."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"fn() {\n  local directory='$1'\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"local-variable-references-local--n",children:["Local Variable References ",(0,r.jsx)(n.code,{children:"local -n"})]}),"\n",(0,r.jsxs)(n.p,{children:["References to outside variables can be created using ",(0,r.jsx)(n.code,{children:"local -n"}),". References will modify the original variable inside the function similar to the ",(0,r.jsx)(n.code,{children:"&"})," pass by reference in ",(0,r.jsx)(n.code,{children:"C++"}),". The variable name is passed as a string."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'add_world() {\n  local -n greeting_ref=$1\n  echo "$greeting_ref" # Hello\n  greeting_ref+=\', World\'\n  echo "$greeting_ref" # Hello, World\n}\n\nGREETING=Hello\n\nadd_world GREETING # Pass the variable name as a string\n\necho "$GREETING" # Hello, World\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"returning-exit-codes-return",children:["Returning Exit Codes ",(0,r.jsx)(n.code,{children:"return"})]}),"\n",(0,r.jsxs)(n.p,{children:['Since functions behave like commands, they do not "return" values they return exit codes, 0 for success, and non-zero for failure. The exit code is returned using the ',(0,r.jsx)(n.code,{children:"return"})," keyword. A status of ",(0,r.jsx)(n.code,{children:"return 0"})," at the end is implicit."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'fn() {\n  if ! [[ -d $1 ]]; then\n    # Print error message to stderr\n    echo "Directory does not exist: $1" >&2\n\n    # Exit with error\n    return 1\n  fi\n\n  # Exit with success (implicit behavior)\n  return 0\n}\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"returning-a-value-echo-",children:['"Returning" a Value ',(0,r.jsx)(n.code,{children:"echo ..."})]}),"\n",(0,r.jsxs)(n.p,{children:['Just like commands, functions do not return values in the traditional sense. Instead "values" are printed to ',(0,r.jsx)(n.code,{children:"stdout"})," (or ",(0,r.jsx)(n.code,{children:"stderr"}),") and can be captured with [command substitution]."]}),"\n",(0,r.jsxs)(n.p,{children:["When returning a single value, you can simply use ",(0,r.jsx)(n.code,{children:"echo"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"get_a_value() {\n  echo 'Some string'\n}\n\nSOME_STRING=$(get_a_value)\n\necho \"$SOME_STRING\" # Some string\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'prefix_paths() {\n  local prefix="$1"\n\n  local path\n  for path in "${@:2}"; do\n    echo "$prefix/$path"\n  done\n}\n\nmapfile -t PATHS PATHS <<<"$(prefix_paths \'/usr\' \'bin\' \'lib\' \'share\')"\n\necho "${PATHS[@]}" # /usr/bin /usr/lib /usr/share\n'})}),"\n",(0,r.jsx)(n.h2,{id:"brackets-vs-parentheses",children:"Brackets vs. Parentheses"}),"\n",(0,r.jsxs)(n.p,{children:["In bash you can also define functions using ",(0,r.jsx)(n.code,{children:"()"})," instead of ",(0,r.jsx)(n.code,{children:"{}"}),". This essentially executes the function as a ",(0,r.jsx)(n.a,{href:"subshells",children:"subshell"})," instead of a command group. This is generally not needed."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"fn() (\n  echo 'I am a subshell!'\n)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"passing-stdin-to-functions",children:"Passing STDIN to Functions"}),"\n",(0,r.jsxs)(n.p,{children:["If you pass standard input to a function, similar to a ",(0,r.jsx)(n.a,{href:"subshells",children:"subshell"})," or command group, the first command in the block will receive the input."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"print_stdin() {\n  cat\n}\n\nprint_stdin <<<'Hello!' # Hello!\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You could use this to setup a ",(0,r.jsx)(n.a,{href:"pipes",children:"pipe"})," as a function"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'grep_sort_uniq() {\n  local pattern="$1"\n  grep "$pattern" | uniq | sort\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["STDIN can be captured into a variable using process substitution with ",(0,r.jsx)(n.code,{children:"cat"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'capture_stdin() {\n  local stdin=$(cat)\n  echo "stdin is: $stdin"\n}\n\nprint_stdin <<<"That\'s neat!" # stdin is: That\'s neat!\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Lastly, if you would like to conditionally capture stdin, you check if stdin was given using an ",(0,r.jsx)(n.code,{children:"if"})," statement with ",(0,r.jsx)(n.code,{children:"-t"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"maybe_stdin() {\n  # `stdin` will be the empty string if there is no stdin\n  local stdin=$(if ! [[ -t 0 ]]; then cat; fi)\n\n  if [[ $stdin ]]; then\n    echo \"stdin is: $stdin\"\n  else\n    echo 'No stdin'\n  fi\n}\n\nmaybe_stdin <<<'Here is some input!' # stdin is: Here is some input!\nmaybe_stdin                          # No stdin\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},5658:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>t});var i=s(758);const r={},a=i.createContext(r);function c(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);